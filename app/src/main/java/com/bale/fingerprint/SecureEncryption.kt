package com.bale.fingerprint

import android.annotation.TargetApi
import android.content.ContentValues.TAG
import android.content.Context
import android.os.Build
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import android.support.annotation.RequiresApi
import android.util.Base64
import android.util.Log
import java.security.KeyStore
import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.crypto.spec.GCMParameterSpec


/**
 * Created by Prashant on 10-12-2017.
 */
class SecureEncryption(
    val context: Context?,
    val keyAlias: String
) {

  companion object {
    const val ANDROID_KEY_STORE: String = "AndroidKeyStore"
    const val AES_MODE: String = "AES/GCM/NoPadding"
    const val FIXED_IV: String = "fixed_direct"
    const val UTF: String = "UTF-8"
    const val AES: String = "AES"
    const val tag: String = "SecureEncryption"
  }

  private lateinit var keyStore: KeyStore

  /**
   *
   */
  init {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
      generateKeyStore()
    } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
    }
  }

  /**
   * This handles for the api version after M (API level 23).
   * It uses KeyGenParameterSpec API which is included only for API levels 23 and higher.
   * This method generates a key if already a key with the same name is not generated by the keystore.
   * The keystore in thisn case uses AES algorithm mode of encryption.
   * This is a symmetric mode of encryption i.e it uses same key both for encryption and decryption.
   */
  @RequiresApi(api = Build.VERSION_CODES.M)
  private fun generateKeyStore() {
    try {
      keyStore = KeyStore.getInstance(ANDROID_KEY_STORE)
      keyStore.load(null)
      if(keyStore.containsAlias(keyAlias)) {
        val keyGenerator: KeyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, ANDROID_KEY_STORE)
        keyGenerator.init(
            KeyGenParameterSpec.Builder(
                keyAlias,
                KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT)
                .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                .setRandomizedEncryptionRequired(false)
                .build())
        keyGenerator.generateKey()
      }
    }
    catch (e: Exception) {
      // Need to handle specific exception. Please avoid handling very generic exceptions.
    }
  }


  /**
   * This encrypts the input for the api version after M (API level 23).
   * This method takes in the input which is to be encrypted.
   * Then the key generated above is retrieved from the key store.
   * The input is encrypted to cipher text using this key which is then returned finally.
   */
  @TargetApi(Build.VERSION_CODES.M)
  private fun encryptData(input: String): String? {
    try {
      val bytes = input.toByteArray()
      val key = keyStore.getKey(keyAlias, null) as SecretKey

      val c = Cipher.getInstance(AES_MODE)
      c.init(Cipher.ENCRYPT_MODE, key, GCMParameterSpec(128, FIXED_IV.toByteArray()))
      val encodedBytes = c.doFinal(bytes)
      return Base64.encodeToString(encodedBytes, Base64.DEFAULT)
    } catch (e: Exception) {
      Log.e(TAG, "", e)
    }

    return null
  }

  /**
   * This decrypts the input for the api version after M (API level 23).
   * This method takes in the input which is to be decrypted.
   * Then the key generated above is retrieved from the key store.
   * The input is decrypted to plain text using this key which is then returned finally.
   */
  @RequiresApi(api = Build.VERSION_CODES.M)
  private fun decryptData(input: String): String? {
    try {
      var decode = Base64.decode(input, Base64.DEFAULT)

      var c: Cipher = Cipher.getInstance(AES_MODE)
      var key: SecretKey = keyStore.getKey(keyAlias, null) as SecretKey
      c.init(Cipher.DECRYPT_MODE, key, GCMParameterSpec(128, FIXED_IV.toByteArray()))
      var decodedBytes = c.doFinal(decode)
      return String(decodedBytes)
    }
    catch (e : Exception) {
      Log.e(TAG,"", e);
    }
    return null
  }

}